---
title: "HKSADZal1"
author: "Hanna Kranas"
date: "6 maja 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#TODO:
##symulowanie na podstawie wytrenowanych innej poezji
##litery na wiêcej stanów
##wizualizacja za³adowanych
##opisaæ

```{r, echo=FALSE, include=FALSE}
library(stringr)
library(HMM)
library(tm)
library(lattice)

Sys.setlocale("LC_CTYPE", "polish") #konieczne ¿eby mi dzia³a³y polskie znaki
```

#Przygotowanie danych

##Poniewa¿ ani R ani Python nie radzi³y sobie z usuwaniem niektórych znaków, usuniête zosta³y w notepadzie.  

![R - nie](eR.PNG)
![Python - nie](python.PNG)
![Notepad++ na ratunek!](notepad.PNG)

##Przygotowanie danych wykonane jednak zosta³o g³ównie w R:  
```{r, eval = FALSE}
wczytaj_i_przygotuj <- function(nazwa_pliku='pan-tadeusz.txt', polskie = TRUE){
  docs <- SimpleCorpus(DirSource("D:/studiaIIstopien/SADII/SAD-zal-1",encoding = 'UTF-8'),control = list(language = "pl"))
docs <- tm_map(docs,removePunctuation)
docs <- tm_map(docs,removeNumbers)
docs <- tm_map(docs,stripWhitespace)
plik <- tolower(as.character(docs[[nazwa_pliku]]))
plik <- gsub ("[–….—\t-]", "", plik)
plik <- plik[plik!=""] #usuwam  puste
  if(polskie){
    cat('POLSKIE LITERY! ¹ê!')
  } else {
    plik <- iconv(plik,from="UTF-8",to="ASCII//TRANSLIT") #bez polskich
  }
  return(plik)
}
```
#Kod i symulacje

##Po przygotowaniu pliku, potrzebna nam bêdzie mo¿liwoœæ wyci¹gniêcia symboli z obserwacji:  
```{r, eval = FALSE}
daj_symbole <- function(obserwacja){
  cat('dlugosc obserwacji: ')
  cat(length(obserwacja))
  #ta funkcja ekstrachuje wszystkie unikalne elementy - czyli dla nas symbole
  symbole <- sort(unique(obserwacja))
  return(symbole)
}
```

##Tworzenie HMM i trenowanie algorytmem Bauma-Welcha odbywa siê w ten sposób:
```{r, eval = FALSE}
prob <- function (x) {x / sum (x)} # funkcja pomocnicza

symuluj <- function(obserwacja,stany){
  symbole <- daj_symbole(obserwacja)
  macierz_emisji <- c() #szykujemy macierz emisji
  for(i in 1:length(stany)){
    x <- rep(1/length(symbole),length(symbole))
    x <- x +  rnorm(length(symbole),0,1/1000000) #dajemy ma³e zaburzenie
    x <- abs(x)/sum(abs(x)) #i poprawiamy zeby sie sumowaly do jedynki dalej
    macierz_emisji <- c(macierz_emisji,x)
  }
  #tworzymy hmm'a z nieco-losowymi prawdopodobieñstwami pocz¹tkowymi i przejœæ
  hmm <- initHMM (stany, symbole, startProbs=(prob (runif (length(stany)))), transProbs=apply (matrix (runif (length(stany)*length(stany)), length(stany)), 1, prob), emissionProbs=matrix(macierz_emisji,nrow = length(stany),ncol = length(symbole), byrow = TRUE))
  #uczymy algorytmem Bauma-Welcha
  wynik <- baumWelch(hmm,obserwacja)
  #post_prwdp <- posterior(wynik$hmm, obserwacja)
  return(wynik)
}
```
##Pe³na symulacja dla liter z przygotowanego pliku wygl¹da tak:  
```{r, eval = FALSE}
litery <- function(przygotowany_plik=wczytaj_i_przygotuj()){
  obserwacja <- unlist(strsplit(przygotowany_plik, ''))
  obserwacja <- obserwacja[!is.na(obserwacja)]
  stany <- c('1','2') # dwa stany
  wynik <- symuluj(obserwacja,stany)
  return(wynik)
}
```
##W przypadku s³ów konieczne by³o klastrowanie, poniewa¿ inaczej algorytm Bauma-Welcha nie dawa³ sobie rady. Sufiksy max-3literowe poklastrowane zosta³y po ich d³ugoœci oraz umiejscowieniu samog³osek/spó³g³osek - ³¹cznie 14 klastrów.
```{r, eval = FALSE}
klastruj <- function(obserwacja){
  obserwacja <- gsub ("^[aeyiou][^aeyiou][aeyiou]$", "ara", obserwacja)
    #obserwacja[grepl("^[aeyiou][^aeyiou][aeyiou]$", obserwacja)] ¿eby sobie wyœwietliæ
  obserwacja <- gsub ("^[aeyiou][aeyiou][aeyiou]$", "aaa", obserwacja)
  obserwacja <- gsub ("^[aeyiou][^aeyiou][^aeyiou]$", "arr", obserwacja)
  obserwacja <- gsub ("^[aeyiou][aeyiou][^aeyiou]$", "aar", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][^aeyiou][aeyiou]$", "rra", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][aeyiou][aeyiou]$", "raa", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][aeyiou][^aeyiou]$", "rar", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][^aeyiou][^aeyiou]$", "rrr", obserwacja)
  obserwacja <- gsub ("^[^aeyiou]$", "1", obserwacja)
  obserwacja <- gsub ("^[aeyiou]$", "1", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][^aeyiou]$", "2", obserwacja)
  obserwacja <- gsub ("^[aeyiou][aeyiou]$", "2", obserwacja)
  obserwacja <- gsub ("^[aeyiou][^aeyiou]$", "2", obserwacja)
  obserwacja <- gsub ("^[^aeyiou][aeyiou]$", "2", obserwacja)
  return(obserwacja)
}
```
##Sposób symulacji dla s³ów jest nastêpuj¹cy:  
```{r, eval = FALSE}
slowa <- function(przygotowany_plik=wczytaj_i_przygotuj()){
  #s³owa wymagaj¹ trochê wiêcej przygotowañ
  plik <- unlist(strsplit(przygotowany_plik," "))
  obserwacja <- unlist(str_sub(plik[plik!=""],start=-3)) #wyci¹gamy max-3literowe sufiksy
  obserwacja <- obserwacja[!is.na(obserwacja)]
  obserwacja <- klastruj(obserwacja)
  print(table(obserwacja)) #wypisujê dla informacji o tym ile jakich sufiksów
  stany <- c('1','2','3','4','5') # 5 stanów
  wynik <- symuluj(obserwacja,stany)
  return(wynik)
}
```

```{r, eval = FALSE, echo = FALSE}
testuj <- function(litery_nie_slowa = TRUE, nazwa_pliku = 'pan-tadeusz.txt', polskie = TRUE){
  if(litery_nie_slowa){
  wynik <- litery(wczytaj_i_przygotuj(nazwa_pliku, polskie))}
  else {
  wynik <- slowa(wczytaj_i_przygotuj(nazwa_pliku, polskie))}
  return(wynik)
}
```


```{r, echo = FALSE}
#jak wytrenowanym zrobic nowy zbior - poszukac
#wybrac wiersze
#zasymulowac tym wyuczonym

```

# Wyniki
## Litery z polskimi znakami
```{r, eval = FALSE, echo = FALSE}
#litery
system.time(lit_polskie <- testuj()) # z polskimi
save(lit_polskie, file = "litery-polskie.RData")
grupy <- lit_polskie$hmm$emissionProbs["1",]-lit_polskie$hmm$emissionProbs["2",]
#jak ujemne to bardziej drugi
print('To jest grupa pierwsza:')
cat(names(grupy[grupy>=0]))
print('To jest grupa druga:')
cat(names(grupy[grupy<0]))
xyplot (lit_polskie$hmm$emissionProbs[1,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (lit_polskie$hmm$emissionProbs))), type="h")
xyplot (lit_polskie$hmm$emissionProbs[2,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (lit_polskie$hmm$emissionProbs))), type="h")
```
```{r}
load("litery-polskie.RData")
```
# Litery bez polskich znaków
```{r, eval = FALSE, echo = FALSE}
lit_bezpolskie <- testuj(polskie = FALSE) #bez polskich
save(lit_bezpolskie, file = "litery-bezpolskie.RData")
grupy <- lit_bezpolskie$hmm$emissionProbs["1",]-lit_bezpolskie$hmm$emissionProbs["2",]
#jak ujemne to bardziej drugi
print('To jest grupa pierwsza:')
cat(names(grupy[grupy>=0]))
print('To jest grupa druga:')
cat(names(grupy[grupy<0]))
xyplot (lit_bezpolskie$hmm$emissionProbs[1,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (lit_bezpolskie$hmm$emissionProbs))), type="h")
xyplot (lit_bezpolskie$hmm$emissionProbs[2,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (lit_bezpolskie$hmm$emissionProbs))), type="h")
#mozna jeszcze plotowac posteriori odjete i patrzec gdzie wiecej samoglosek
```
```{r}
load("litery-bezpolskie.RData")
```
# S³owa - sufiksy, klastrowane
```{r, eval = FALSE, echo = FALSE}
slowa_bezpolskie <- testuj(litery_nie_slowa = FALSE,polskie=FALSE)
save(slowa_bezpolskie, file = "slowa.RData")
grupy <- slowa_bezpolskie$hmm$emissionProbs["1",]
xyplot (slowa_bezpolskie$hmm$emissionProbs[1,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (slowa_bezpolskie$hmm$emissionProbs))), type="h")
xyplot (slowa_bezpolskie$hmm$emissionProbs[2,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (slowa_bezpolskie$hmm$emissionProbs))), type="h")
xyplot (slowa_bezpolskie$hmm$emissionProbs[3,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (slowa_bezpolskie$hmm$emissionProbs))), type="h")
xyplot (slowa_bezpolskie$hmm$emissionProbs[4,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (slowa_bezpolskie$hmm$emissionProbs))), type="h")
xyplot (slowa_bezpolskie$hmm$emissionProbs[5,] ~ c(1:length(grupy)), scales=list(x=list(at=1:length(grupy), labels=colnames (slowa_bezpolskie$hmm$emissionProbs))), type="h")
```

```{r}
load("slowa-wiecej.RData")
load("slowa-mniej.RData")
```

#Symulowanie na ulubionej poezji wytrenowanymi modelami

```{r}
przygotowany_plik <- wczytaj_i_przygotuj(nazwa_pliku = 'dzabbersmok.txt',polskie=TRUE)
obserwacja <- unlist(strsplit(przygotowany_plik, ''))
obserwacja <- obserwacja[!is.na(obserwacja)]
post.prob.dzabber.pol <- posterior(lit_polskie$hmm, obserwacja)
sum(post.prob.dzabber.pol[1,][grepl('[aeiouy¹êó]',obserwacja)])/sum(grepl('[aeiouy¹êó]',obserwacja)) #samogloski naleza do pierwszego z 96% prwdp!

#bezpolskie

przygotowany_plik <- wczytaj_i_przygotuj(nazwa_pliku = 'dzabbersmok.txt',polskie=FALSE)
obserwacja <- unlist(strsplit(przygotowany_plik, ''))
obserwacja <- obserwacja[!is.na(obserwacja)]
post.prob.dzabber.bezpol <- posterior(lit_bezpolskie$hmm, obserwacja)
sum(post.prob.dzabber.bezpol[2,][grepl('[aeiouy]',obserwacja)])/sum(grepl('[aeiouy]',obserwacja)) #samogloski naleza do drugiego z 95% prwdp!
#wizualizacja - suma po samogloskach dla stanu 1? czy coœ
#generalnie czy posterior prob wy¿sze w którymœ stanie wystêpuj¹ tam gdzie samogl


```
